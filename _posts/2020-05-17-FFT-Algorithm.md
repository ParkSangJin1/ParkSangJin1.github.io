---
layout: single
title:  "FFT Algorithm"
date:   2020-05-17 17:41:14 +0900
---



# FFT란?



 FFT란 __Fast Fourier Trasform(고속 푸리에 변환)__으로, 말그대로 빠른 푸리에 변환이다.

푸리에 변환은 시간에 대한 함수를 변환을 통해서 주파수 성분으로 분해하는 방법으로, sin, cos함수로 나타낼 수 있게 한다.

그 중에서도 FFT는 이산적인 데이터를 변환하는데, 일반적으로 적용되는 DFT(Discrete Fourier Transform, 이산 푸리에 변환)들보다 훨씬 더 좋은 성능을 갖고 있다.





# FFT 알고리즘 동작 방식



FFT 알고리즘 중에 가장 널리 알려져 있고, 많이 쓰는 알고리즘은

1965년 개발된 __"쿨리-튜키 알고리즘(Cooly-Tukey Algorithm)"__ 이다.

쿨리튜키 알고리즘은 분할정복 알고리즘(Divide and conquer)을 사용하는데,

$n=N_1N_2$ 일때, $N_1,N_2$로 나누어 재귀적으로 DFT를 사용하는 방법이다.



이 알고리즘은 일반적으로 $n=2^k$ 일 때 많이 사용하는데, 재귀적으로 2등분을 하면서 분할정복을 적용하기 때문이다.

하지만 굳이 2의 거듭제곱 꼴이 아니라, 다른 합성수의 경우에도 적용이 가능하다.



다음 사진은 $n=16$ (여기서 $n$은 point의 개수) 일 때의 FFT 적용과정을 예로 들어보았다.

![](https://i.stack.imgur.com/KNiJM.png)

맨 윗줄은 신호의 갯수 $16=N_1N_2$ 일 때, $N_1=8,N_2=2$ 로,

그 밑의 줄들은 각각 $n=8$ 일 때, $n=4$ 일 때, $n=2$ 일 때를 다시 나누어 적용을 하는 과정이다.

위와 같이 분할정복을 재귀적으로 이용하면 일반적인 계산보다 더 효율적일 수 있다.



# 성능 분석



결론부터 말하자면,

일반적으로 계산되는 DFT 알고리즘은 $O(n^2)$ 의 시간복잡도를 가지지만, FFT 알고리즘은 $O(n log_2 n)$의 시간 복잡도를 가진다. 



$F_k = \sum\limits_{m=0}^{n-1}f_mW^{km}$       $(W=e^{2π/N})$ 



위의 식을 일반적으로 계산하게 되면 $W$ 의 계산을 따로 하더라도 $n^2$ 회의 곱셈을 해야 한다.

하지만 고속 푸리에 변환의 경우에는



$φ_{k_1m_2} = W^{k_1m_2}\sum\limits_{m_1=0}^{N_1-1}f_{N_2m_1+m_2}W^{N_2k_1m_1}$         $(k_1=0,...,N_1-1 ; m_2=0,...,N_2-1)$

$F_{k_1+N_2k_1} = \sum\limits_{m_2=0}^{N_2-1}φ_{k_1m_2}W^{N_1k_2m_2}$             $(k_1=0,...,N_1-1 ; k_2=0,...,N_2-1)$


위의 식과 같이 $n$ 값을 $n=N_1N_2$ 와 같이 소인수 분해 후 낮은 차수로 변환한 다음,

2단계로 분해 실행, 즉 분할 정복을 이용해 계산 할 수 있는 것이다. 이 단계에서 효율이 좋다고 볼 수 있다.



특히 $n=2^k$ 꼴일 경우, $(n=2×N_1) or  (n=N_2 ×2)$ 꼴로 나타낼 수 있고, 이 연산을 재귀적으로 반복하여

최종적으로 곱셈횟수를 $n(n-2)/2$ 번 정도로 줄일 수 있게 된다.

최악의 경우일지라도, $nlog_2n$ 번의 연산을 필요로 하므로 $n^2$번의 연산을 필요로하는 DFT보다 FFT가 효율적이다.